function [BW,inv_BW, maskedRGBImage] = createGreenMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder App. The colorspace and
%  minimum/maximum values for each channel of the colorspace were set in the
%  App and result in a binary mask BW and a composite image maskedRGBImage,
%  which shows the original RGB image values under the mask BW.

% Auto-generated by colorThresholder app on 08-Oct-2016
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.327;
channel1Max = 0.474;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.167;
channel2Max = 0.733;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.118;
channel3Max = 0.298;

% Create mask based on chosen histogram thresholds
BW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
BW = bwareaopen(BW, 200);
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
R = maskedRGBImage(:,:,1);
G = maskedRGBImage(:,:,2);
B = maskedRGBImage(:,:,3);
R(BW) = 0;
G(BW) = 255;
B(BW) = 0;
maskedRGBImage(:,:,1)=R;
maskedRGBImage(:,:,2)=G;
maskedRGBImage(:,:,3)=B;


split = sum(BW);
split = find(split~=0);
x = []; x(1,1) = split(1); k = 1;
for i=2:size(split,2)
    if(abs(split(i-1)-split(i))>1)
        x(k,2) = split(i-1);
        x(k+1,1) = split(i);
        k = k+1;
    end
end
x(k,2) = split(end); y = [];
for i = 1:size(x,1)
    bw_cut = BW(:,x(i,1):x(i,2),:);
    bw_cut = sum(bw_cut');
    idx = find(bw_cut~=0);
    y = [y; min(idx),max(idx)];
end
inv_BW = logical(zeros(size(maskedRGBImage,1),size(maskedRGBImage,2)));
for i = 1:size(x,1)
    mask = logical(zeros(size(maskedRGBImage,1),size(maskedRGBImage,2)));
    mask(y(i,1):y(i,2),x(i,1):x(i,2))=true;
    mask = ~BW&mask;
    image = rgb2gray(RGB);
    square = image.*uint8(mask);
    square =  square(y(i,1):y(i,2),x(i,1):x(i,2));
    level = graythresh(square);
    square_bw = im2bw(square,level);
    white = sum(sum(square_bw));
    black = size(square_bw,1)*size(square_bw,2)-white;
    if(white>black) % Controllare
        inv_BW(mask) = 255;
    else
        inv_BW(mask) = 0;
    end
end

centers = zeros(5,5,2,size(x,1));
for i = 1:size(x,1)
    color = BW(y(i,1):y(i,2),x(i,1):x(i,2));
    se = strel('disk', 3);
    color = imclose(color,se);    
    d = size(color,1); j=1; 
    for k=floor(d/10):2*floor(d/10):d
        centers(j,:,2,i) = k;
        vline = color(k,:);
        idx = find(vline~=0);
        if(size(idx,2) ~= 0) % Se fa break i corrispondenti neppure vanno considerati
            xx = []; xx(1,1) = idx(1); kk = 1;
            for jj=2:size(idx,2)
                if(abs(idx(jj-1)-idx(jj))>1)
                    xx(kk,2) = idx(jj-1);
                    xx(kk+1,1) = idx(jj);
                    kk = kk+1;
                end
            end
            xx(kk,2) = idx(end);
            for jj=1:size(xx,1)
                centers(j,jj,1,i) = 0.5*(xx(jj,2)-xx(jj,1))+xx(jj,1);
            end
        end
        j = j+1;
    end
end

for i = 1:size(x,1)
    color = BW(y(i,1):y(i,2),x(i,1):x(i,2));
    dim = size(color,1);
    j = size(centers,2);
    for k=1:size(centers,2)
        x_axis = [centers(1,k,1,i), centers(3,k,1,i), centers(5,k,1,i)];
        y_axis = [centers(1,k,2,i), centers(3,k,2,i), centers(5,k,2,i)];
        if(sum(x_axis)>0 && k<=j)
            xq_axis = 0:0.001:dim;
            if(x_axis(1) == x_axis(2))
               x_axis(2) = x_axis(2)+ 0.0001;
            elseif(x_axis(2) == x_axis(3))
                x_axis(3) = x_axis(3)+ 0.0001;
            end
            line = pchip(x_axis,y_axis,xq_axis);
            line2 = abs(centers(2,k,2,i)-line);
            val = min(line2);
            idx = find(line2==val);
            centers(2,j,1,i) = xq_axis(min(idx));
            line2 = abs(centers(4,k,2,i)-line);
            val = min(line2);
            idx = find(line2==val);
            centers(4,j,1,i) = xq_axis(min(idx));
        end
        x_axis = [centers(2,k,1,i), centers(4,k,1,i)];
        y_axis = [centers(2,k,2,i), centers(4,k,2,i)];
        if(sum(x_axis)>0  && k<=j)
            xq_axis = 0:0.001:dim;
            if(x_axis(1) == x_axis(2))
               x_axis(2) = x_axis(2)+ 0.0001;
            end
            
            line = pchip(x_axis,y_axis,xq_axis);
            
            line2 = abs(centers(1,k,2,i)-line);
            val = min(line2);
            idx = find(line2==val);
            centers(1,j,1,i) = xq_axis(min(idx));
            
            line2 = abs(centers(3,k,2,i)-line);
            val = min(line2);
            idx = find(line2==val);
            centers(3,j,1,i) = xq_axis(min(idx));
            
            line2 = abs(centers(5,k,2,i)-line);
            val = min(line2);
            idx = find(line2==val);
            centers(5,j,1,i) = xq_axis(min(idx));
        end
        j = j-1;
    end
     for k=1:size(centers,1)
         centers(k,:,1,i) = sort(centers(k,:,1,i));
     end
end

% for i = 1:size(centers,4) % Immagini
%     color = BW(y(i,1):y(i,2),x(i,1):x(i,2));
%     se = strel('disk', 3);
%     color = imclose(color,se);
%     color = imerode(color,se);
%     d = size(color,1); j=1; 
%     CC = bwconncomp(color,4);
% %     S = regionprops(CC,'Centroid');
% %     L = bwlabel(color,4);
%     for j = 1:size(centers,1) %Riga
%         for k = 1:size(centers,2) %Colonna
%             %[centers(j,k,1,i), centers(j,k,2,i)] = updatePos(centers(j,k,1,i), centers(j,k,2,i));
%             if(centers(k,j,1,i) == 0)
%                 first = k+1;
%             end
%             if(j==1 && k ==first)
%                 neighbour = ['right', 'down'];
%             elseif(j==5 && k == 5)
%                 neighbour = ['left', 'up'];
%             elseif(j==1 && k == 5)
%                 neighbour = ['down', 'left'];
%             elseif(j==5 && k == first)
%                 neighbour = ['right', 'up'];   
%             elseif(j==5 && k>first && k<5)
%                 neighbour = ['right', 'left', 'up'];  
%             elseif(j>1 && j<5 && k == first)
%                 neighbour = ['right', 'down', 'up'];   
%             elseif(j==1 && k>first && k<5)
%                 neighbour = ['right', 'down', 'left'];
%             elseif(j>1 && j<5 && k == 5 )
%                 neighbour = ['down', 'left', 'up'];
%             end
%             
%              if(color(centers(j,k,2,i),centers(j,k,1,i))) % Se il pixel è colorato fai una cosa altrimenti un altra
%                 
%              else
%                  
%              end
%         end
%     end
% end
for i = 1:size(x,1)
    color = BW(y(i,1):y(i,2),x(i,1):x(i,2));
    figure,imshow(color); hold on;
    for k=1:5
        for j=1:5
            scatter(centers(k,j,1,i),centers(k,j,2,i)) % Riferimento Y verso il basso
        end
    end
end


% Riorganizzare i punti a partire dalla configurazione approssimativa

% trovare nei centri l'oggetto reale, spostarsi a sinistra e a destra
% muovendosi sempre sul più vicino rispetto a quello vero
% aggiornare con la posizione assoluta

for i = 1:size(x,1)
    for k=1:5
        for j=1:5
            if(centers(k,j,1,i) ~= 0)
                centers(k,j,1,i) = x(i,1) + centers(k,j,1,i);
                centers(k,j,2,i) = y(i,1) + centers(k,j,2,i);
            else
                centers(k,j,2,i) = 0;
            end        
        end
    end
end

figure,imshow(BW); hold on;
for i = 1:size(x,1)
    for k=1:5
        for j=1:5
            scatter(centers(k,j,1,i),centers(k,j,2,i)) % Riferimento Y verso il basso
        end
    end
end


disp('ciao');
close all;
